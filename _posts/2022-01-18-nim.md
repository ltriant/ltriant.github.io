---
layout: post
title: "Nim"
description: "Adding Nim to my stack of languages"
date: 2022-01-18 00:00:00
---

A few years ago, I came to the realisation that I'd mostly become a programming language one-trick pony, and that language was Perl. It was the first real programming language I learned when I was a teenager, back when CGI still mostly ruled the web. I knew a couple of other languages for certain specific needs — like PHP for web dev — and I'd dipped in and out of many other programming languages over the years — like Python and Common Lisp and Haskell — but as soon as I was doing anything even remotely complicated, Perl was the hammer I reached for.

Since then, I've been on a journey to develop a toolbox of a few languages that I don't need super deep knowledge of, but I know enough of to have the breadth to tackle almost any problem that I'm realistically likely to come across in any personal projects.

Excluding the languages that I'm required to know for work (Clojure and TypeScript), my toolbox recently looked something like this:

* **Python** For most scripting needs, when performance doesn't matter, strong types aren't necessary, or when Bash is no longer appropriate. On occasion I do some data crunching and graphing, and [Pandas](https://pandas.pydata.org/) has been a great library in that space.
* **Rust** My goto language for almost every non-trivial project for the past few years, including emulators, and command-line tools. It's a joy to write code in _most_ of the time.
* **Go** For building small web services, or any other kind of networked, concurrent service. The standard library is great, the compiler produces static binaries, and it has the best cross-compilation story of anything else I've used.

The problem I face is that although I've used Rust for most of my projects in recent years, I feel like the strictness of the language slows me down a lot for smaller projects, and occasionally that slowness is enough to discourage me from even starting.

I need something that's less strict than Rust — not necessarily to replace Rust, but as an alternative that allows me to do certain things a bit quicker.

I don't like Python for anything that's better served with some strong typing, and I don't love Go for anything outside of concurrent, networked stuff, or if I need to easily cross-compile something for a Windows user.

I'd been watching [Nim](https://nim-lang.org/) for some time, and I felt like it could fill this need for me, so I tried it out.

![Conway's Game of Life](/assets/game-of-life.gif){:.post-image}

I started with a [Game of Life simulator](https://gist.github.com/ltriant/ad76ba19febb8a06f3bc0ed87341390b) — which has become my de facto standard simple first project for trying out a new language. I also ported my [tree](https://github.com/ltriant/tree) project from C. And I participated in [Advent of Code 2021](https://adventofcode.com/2021/) using Nim exclusively.

And I _really_ enjoyed it. Much more than I thought I would.

At version 1.6.2, it's fairly mature, and it definitely felt that way with its documentation, tooling, and standard library. I was weary about the syntax, as I don't usually love anything whitespace-aware, but it grew on me much faster than I expected.

Although I wish the APIs were a little more aligned as I feel like it is in Rust — `incl` and `excl` instead  of `add` and `remove` feels odd for a hash table implementation — the collections libraries felt complete enough to do anything I needed for Advent of Code. This naive implementation of [Dijkstra's algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) rolled off the keyboard pretty easily:

```nim
import algorithm
import sequtils
import sets
import sugar
import tables

type
  DijkstraResult = tuple
    distances: Table[(int, int), int]
    path: Table[(int, int), (int, int)]

func dijkstra(graph: seq[seq[int]], origin: (int, int), destination: (int, int)): DijkstraResult =
  var
    nodes = initHashSet[(int, int)]()
    dist  = initTable[(int, int), int]()
    prev  = initTable[(int, int), (int, int)]()

  for r, row in graph:
    for c, x in graph[r]:
      dist[(r, c)] = high(int)
      nodes.incl((r, c))

  dist[origin] = 0

  while nodes.len > 0:
    let (r, c) = nodes.toSeq.sorted((x, y) => cmp(dist[x], dist[y]))[0]

    nodes.excl((r, c))

    if (r, c) == destination:
      break

    var neighbors = newSeq[(int, int)]()

    if r > 0: neighbors.add((r - 1, c))
    if r < graph.high: neighbors.add((r + 1, c))
    if c > 0: neighbors.add((r, c - 1))
    if c < graph[r].high: neighbors.add((r, c + 1))

    for (nr, nc) in neighbors.filter(p => nodes.contains(p)):
      let alt = dist[(r, c)] + graph[nr][nc]
      if alt < dist[(nr, nc)]:
        dist[(nr, nc)] = alt
        prev[(nr, nc)] = (r, c)

  return (dist, prev)
```

Having written _a lot_ of Perl and Clojure, I've grown to appreciate the ability to write code in whichever style I want, and that kind of expressiveness is certainly at the core of Nim with some sugary syntax like `=>` notation, keyword arguments, optional round brackets for function calls, etc.

I'm a big fan of this, and it's definitely what I was looking for.

# What about language X?

I immediately discounted D, C++, Swift, and some of the other bigger languages, because they play in the same space as Rust a little too much, are complicated languages with lots of features, and have steep learning curves, which is not something I wanted to deal with.

What about C? I love C, and although I wasn't explicit about it above, I'm actually trying to remove C from my toolbox. I don't write C for a living, and when I do, I spend way too much time thinking about whether or not I'm mixing integer types in a bad way, and whether I'm freeing the right memory, to the point that I spend less time thinking about the actual problem that I'm solving and more time avoiding undefined behaviour.

I tried out Zig aswell, and while I liked it, I didn't love it. I could definitely feel that Zig is a pre-1.0 language, so it's to be expected that things would be missing or feel unfinished.

Something that felt cumbersome was overflow addition, which is super common in emulators. For example, in [a CHIP-8 emulator](https://github.com/ltriant/chip8z), I implemented subtraction via addition with the two's complement.

So, where I wanted to express `VX = (~VY + 1)  + VX`, I might write something like this in Rust:

```rust
self.V[vx] = (!self.V[vy])
	.wrapping_add(1)
	.wrapping_add(self.V[vx])
```

However, because Zig's `@addWithOverflow` function doesn't return the new value, but instead modifies one of its parameters with the result of the overflowing addition, a temporary variable is needed. The return value is true or false, depending on if an overflow occurred.

```zig
var tmp_vy: u8 = 0;
var v = @addWithOverflow(u8, ~self.V[vy], 1, &tmp_vy);
v = @addWithOverflow(u8, self.V[vx], tmp_vy, &self.V[vx]);
```

This isn't as expressive as I wanted it to be, and I ran into this sort of problem a few times.

In Nim, overflowing addition is performed by default on unsigned integer types — which is handy in emulation projects — and throws an exception for signed integers. That... could get confusing, but it's fine for now.

I'm still keeping my eye on Zig as it gets closer to 1.0, but it didn't hit the mark for me _yet_.
